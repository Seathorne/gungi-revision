# Gungi

# Commands
- On the first turn, [back] or [.] will toggle input-logging, which is on by default.
- [m], [y], [l], ... The character abbreviation for any piece can be used to select one of those pieces from in-hand.
- [r-f-t] selects a piece on the board at the specified location, or selects a destination location for a piece to move or attack.
- [r-f] may be used to specify a non-ambiguous location. When selecting a piece, this defaults to the top stacked piece. When moving and attacking, this may be used if only one action is possible on the destination location.
- [pass] passes a player's turn during the setup phase once the minimum number of setup pieces (18) has been placed
- [done] completes a player's setup phase, regardless of whether the other player's setup phase is complete.
- [back] or [.] returns to the previous menu, deselecting a piece if it was selected.

# Rules
I will eventually make a nice document that details the rules I used for my version, but for now, this is the document to which most of the rules adhere: https://www.docdroid.net/G3kkTrR/gungi-rules.pdf. Notably, the ruleset Dots and I have settled on makes these changes:  each player's marshal is required to be placed first, pawns can never move two spaces forward, and the lieutenant general's front corner attacks can only be reached through the space directly in front of the piece. Here is my spreadsheet, which shows all movesets in a more condensed space: https://docs.google.com/spreadsheets/d/1MOFiqySKJsqzqdqSt0QPw027icjcgm55nK1u1-E7wow/edit?usp=sharing.

# Rewrite
I wasn't happy with the organization or performance of my first implementation of Gungi, so I decided to rewrite the entire program from scratch following a new approach. Previously, I used an array-based approach: movesets, line of sight, drops, moves, attacks, etc. were all stored inside simple 9x9x3 arrays of integers. This worked fine at first, as it was easy to AND together multiple arrays to yield a result, such as [moveset] & [line of sight] & [open spots on the board] = [valid moves]. Unfortunately, once I got around to checking conditions such as checkmate, where hundreds or thousands of these arrays must be calculated to check all possible drops, moves, and attacks, my logic started getting unorganized, and performance was not great (confirming checkmate took a few seconds).

Another major issue from my approach was that these arrays did not hold much data about the pieces in them. The board array held three pieces of information about each piece: which color player owned it (sign), what type of piece it was (magnitude), and its location in the array. Locations were annoying to deal with, as they were a property of the array and not the pieces themselves. I found myself wishing I could have more information tied to the array. I was calculating each pieces' location, flattening that piece into an integer in an array, and then later needing to get the location of a filled spot in the array, and having to search through every piece to find the piece with that location. This was an inefficient approach, when I should just access the pieces directly instead of flattening into integers.

My new approach is much more object-oriented, more easily adjustable and debuggable, more organized, and much more efficient. Now, an entire game can run in a couple seconds (99% of which is time taken for printing, I believe). Pieces, locations, players, and boards are their own objects, and as such, I can access them much more easily and quickly, especially when clone them for testing checkmate. Moveset calculations are separated into a new class, and drop calculations are performed by each board (as valid drop locations are mostly the same for each piece). Each piece is owned by a player, which is owned by a board, and each of these can access public properties and methods of the other. Instead of being array-based, most of the calculations and storage of valid locations occur in lists or in 2D arrays of lists. The layout for these is much easier to search and update, and they greatly reduce the number of empty locations being checked. I also separated my previous mess of a constants class into a utility class with general methods and a properties class with constant values.

Most of the new features that I implemented to this rewrite could have been added to my previous version, but it would have been more of a hassle to do so. One handy feature is a much more dynamic menu (instead of selecting [move] or [drop], then selecting a piece, the user can select a piece from their hand or the board whenever they want). The user can also return to the previous menu, so they can't be locked into an unwanted option. Locations for selecting, dropping, moving, and attacking pieces now allow the user to only specify their rank and file (row and column), leaving off their tier, if there is no ambiguity to the location (i.e. no two possible actions with the same rank and file). A game now automatically logs all user inputs to a file, and those inputs can then be copied back into a new game. This allows for "pausing" a game, preventing losing a game if the program closes or an error occurs, and more easily debugging the same game setup repeatedly.

Printing has been improved, now allowing me to easily change what should be printed. When a piece is selected and the board is printed, the board will automatically print the pieces' drop locations if it is in-hand, or its movement and attack locations if it is on the board. Additionally, if a marshal is placed into check, the board will print the locations of the attackers. A player's hand of available pieces to drop also prints in the legend beside the side of the board. Overall, the new version runs much faster, is more organized, and is nicer to use than the first version, so I'm satisfied with putting in the effort to rewrite it.
